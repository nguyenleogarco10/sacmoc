<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sắc Mộc - Thử Son Ảo Nâng Cấp </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js"></script>
    <style>
        body {
            font-family: 'Quicksand', sans-serif;
            background-color: #FDFBF8; /* Nền nhẹ nhàng, ấm áp */
            color: #4A4A4A;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 1.5rem; /* Tăng padding tổng thể */
            box-sizing: border-box;
        }
        .text-brand { color: #8D6E63; } /* Màu nâu đất chủ đạo */

        #vto-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* Tăng khoảng cách giữa các phần */
            padding: 2rem; /* Tăng padding bên trong container */
            background-color: white;
            border-radius: 1rem; /* Bo góc mềm mại hơn */
            box-shadow: 0 15px 30px -8px rgba(0,0,0,0.15), 0 8px 12px -4px rgba(0,0,0,0.08); /* Đổ bóng sâu hơn */
            width: 100%;
            max-width: 950px; /* Rộng hơn một chút */
        }
        #vto-video-container {
            position: relative;
            width: 100%;
            max-width: 550px; /* Rộng hơn */
            aspect-ratio: 4 / 3;
            background-color: #EFEBE9;
            border-radius: 0.75rem; /* Bo góc */
            overflow: hidden;
            border: 1px solid rgba(141, 110, 99, 0.2); /* Viền mềm mại */
            box-shadow: 0 5px 15px -3px rgba(0,0,0,0.1); /* Đổ bóng nhẹ */
            transition: box-shadow 0.3s ease-out, border-color 0.3s ease-out; /* Add transition for glow effect */
        }
        #vto-video-container.face-detected {
            box-shadow: 0 0 0 5px rgba(141, 110, 99, 0.5), 0 0 20px rgba(141, 110, 99, 0.3); /* Glowing effect */
            border-color: #8D6E63;
        }

        #vto-video, #vto-canvas, #vto-face-static {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #vto-video {
            transform: scaleX(-1); /* Mirror mode */
        }
        #vto-canvas {
            pointer-events: none;
            /* Transition for smoother color application (if applicable to canvas/overlay) */
            /* Note: Canvas drawing doesn't directly support CSS transitions on fillStyle, handled by JS */
        }
        #vto-lips-overlay {
             position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            clip-path: polygon(29% 62%, 35% 58%, 43% 56%, 50% 57%, 57% 56%, 65% 58%, 71% 62%, 65% 66%, 57% 68%, 50% 69%, 43% 68%, 35% 66%);
            transition: background-color 0.3s ease-in-out; /* For static preview */
        }
        #vto-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem; /* Tăng khoảng cách */
            width: 100%;
            max-width: 550px;
        }
        #vto-color-options {
            display: grid;
            grid-template-columns: repeat(6, minmax(0, 1fr)); 
            gap: 0.85rem; /* Tăng khoảng cách giữa các nút màu */
            width: 100%;
            overflow-x: auto; /* Enable horizontal scroll for many items */
            padding-top: 0.75rem; /* Add padding to the top to prevent clipping of active border/shadow */
            padding-bottom: 0.5rem; /* Keep existing padding-bottom */
            padding-left: 0.75rem; /* NEW: Add padding to the left to prevent clipping */
            padding-right: 0.75rem; /* NEW: Add padding to the right to prevent clipping */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        /* Hide scrollbar for aesthetic purposes */
        #vto-color-options::-webkit-scrollbar {
            display: none;
        }
        #vto-color-options {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        @media (max-width: 768px) {
            #vto-color-options {
                grid-template-columns: repeat(4, minmax(0, 1fr)); /* 4 cột trên tablet */
            }
        }
        @media (max-width: 480px) {
            #vto-color-options {
                grid-template-columns: repeat(3, minmax(0, 1fr)); /* 3 cột trên di động */
            }
        }
        .vto-color-btn {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 0.5rem; /* Bo góc nhiều hơn */
            border: 2px solid transparent;
            cursor: pointer;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, transform 0.1s ease-out; /* Thêm transition cho transform */
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); /* Đổ bóng nhẹ mặc định */
        }
        .vto-color-btn:hover {
            border-color: #8D6E63;
            box-shadow: 0 0 0 3px #D7CCC8; /* Hiệu ứng sáng viền mạnh hơn khi hover */
            transform: translateY(-2px); /* Hiệu ứng nổi nhẹ */
        }
        .vto-color-btn.active {
            border: 4px solid #8D6E63; /* Increased border to make it more prominent and ensure visibility */
            box-shadow: 0 0 0 5px #8D6E63; /* Slightly increased shadow spread */
            transform: scale(1.07); /* Slightly increased scale to give more room */
        }

        /* NEW CSS for Custom Color Picker Button */
        #custom-color-btn {
            grid-column: span 6; /* Spans across all 6 columns on desktop */
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #EFEBE9;
            color: #8D6E63;
            font-weight: 600;
            border-radius: 0.5rem;
            border: 2px solid #D7CCC8;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            padding: 0.75rem;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        #custom-color-btn.active {
            border: 4px solid #8D6E63;
            box-shadow: 0 0 0 5px #8D6E63;
            transform: scale(1.03);
        }
        #custom-color-btn:hover {
             border-color: #8D6E63;
             background-color: #EFEBE9;
        }

        /* Responsive adjustments for the custom button */
        @media (max-width: 768px) {
            #custom-color-btn {
                grid-column: span 4; /* Spans 4 columns on tablet */
            }
        }
        @media (max-width: 480px) {
            #custom-color-btn {
                grid-column: span 3; /* Spans 3 columns on mobile */
            }
        }

        /* NEW CSS for Color Picker Modal */
        #color-picker-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            -webkit-backdrop-filter: blur(5px);
            backdrop-filter: blur(5px);
        }
        .color-picker-content {
            background-color: white;
            padding: 2rem;
            border-radius: 1rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            text-align: center;
            width: 90%;
            max-width: 600px; /* Make it wider to fit the color palette */
        }
        .color-picker-content h4 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #8D6E63;
        }

        /* Styles for the new color picker UI */
        .color-picker-ui {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        @media (min-width: 640px) {
             .color-picker-ui {
                flex-direction: row;
             }
        }
        .color-palette-container {
            position: relative;
            width: 100%;
            aspect-ratio: 1 / 1;
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: inset 0 0 0 1px #ccc; /* Inner border */
        }
        .color-palette-canvas {
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        .color-slider-container {
            position: relative;
            width: 25px; /* Fixed width for the slider */
            height: 100%;
            overflow: hidden;
            border-radius: 0.5rem;
            box-shadow: inset 0 0 0 1px #ccc; /* Inner border */
        }
        .color-slider-canvas {
            width: 100%;
            height: 100%;
            cursor: ns-resize;
        }

        .picker-controls {
            /* --- THAY ĐỔI CẦN THIẾT --- */
            display: flex;
            flex-direction: column;
            gap: 1rem;
            justify-content: space-between;
            align-items: stretch;
            flex-grow: 1; /* Allow it to take up remaining space */
            /* --- KẾT THÚC THAY ĐỔI --- */
        }
        .hex-code-display {
            font-family: 'Courier New', Courier, monospace;
            font-size: 1rem;
            font-weight: 600;
            color: #4A4A4A;
            background-color: #EFEBE9;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
        }
        
        /* NEW: Visual color display below hex code */
        .color-preview-box {
            width: 100%;
            /* --- THAY ĐỔI CẦN THIẾT --- */
            height: 150px;
            /* --- KẾT THÚC THAY ĐỔI --- */
            border-radius: 0.5rem;
            border: 1px solid #ccc;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .picker-done-btn, .picker-cancel-btn {
            padding: 0.75rem 1.5rem;
            color: white;
            font-weight: 700;
            border-radius: 0.75rem;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .picker-done-btn {
            background-color: #8D6E63;
        }
        .picker-done-btn:hover {
            background-color: #7A5D4D;
            transform: translateY(-2px);
        }
        .picker-done-btn:active {
            transform: translateY(0);
        }
        .picker-cancel-btn {
            background-color: #D7CCC8;
            color: #4A4A4A;
            margin-top: 0.5rem; /* Space below done button */
        }
        .picker-cancel-btn:hover {
            background-color: #C2B4B2;
            transform: translateY(-2px);
        }
        .picker-cancel-btn:active {
            transform: translateY(0);
        }


        #vto-status {
            text-align: center;
            padding: 0.75rem 1.25rem; /* Tăng padding */
            background-color: rgba(255,255,255,0.9);
            border-radius: 0.5rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Căn giữa hoàn hảo */
            z-index: 10;
            font-size: 1rem;
            color: #555;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex; /* Để căn giữa spinner */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .hidden {
            display: none !important;
        }

        /* Loading Spinner for VTO Status */
        .spinner {
            border: 4px solid rgba(141, 110, 99, 0.1);
            border-top: 4px solid #8D6E63;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
            /* Đảm bảo spinner không bị biến dạng */
            flex-shrink: 0; 
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Styles for the assistant chatbox */
        #assistant-chatbox {
            background-image: linear-gradient(to bottom right, #f0f4f7, #e6edf2); /* Gradient tinh tế */
            border: 1px solid #b0c7d8; /* Viền tinh tế hơn */
            border-radius: 1.25rem; /* Bo góc nhiều hơn */
            padding: 1.5rem; /* Tăng padding */
            margin-top: 2rem; /* Tăng margin top */
            width: 100%;
            max-width: 600px; /* Rộng hơn nữa */
            min-height: 120px; /* Taller */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            text-align: center;
            box-shadow: 0 12px 25px -8px rgba(0,0,0,0.2), 0 6px 10px -3px rgba(0,0,0,0.12); /* Đổ bóng mạnh hơn */
            position: relative;
        }
        #assistant-chatbox h3 {
            font-size: 1.35rem; /* Lớn hơn một chút */
            font-weight: 700; /* Đậm hơn */
            color: #2a3c4a; /* Màu chữ tối hơn */
            margin-bottom: 1rem; /* Tăng khoảng cách dưới tiêu đề */
            display: flex;
            align-items: center;
            gap: 0.75rem; /* Tăng khoảng cách giữa icon và chữ */
        }
        /* Avatar animation */
        .avatar-pulse {
            animation: avatarPulse 2s infinite ease-in-out;
        }
        @keyframes avatarPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .assistant-message-container {
            flex-grow: 1; /* Allows it to take available space */
            width: 100%;
            display: flex;
            justify-content: center; /* Center message horizontally */
            align-items: flex-start; /* Align message to the top */
            padding-bottom: 1rem;
            min-height: 80px; /* Ensure space for messages */
        }

        .assistant-message {
            font-size: 1rem; /* Kích thước chữ lớn hơn */
            color: #333;
            line-height: 1.5; 
            text-align: left; 
            word-wrap: break-word; /* Đảm bảo từ dài xuống dòng */
            padding: 0; /* Remove padding here, controlled by inner elements */
            max-width: 90%; 
            margin: 0 auto; 
            /* text-indent and white-space properties removed from here to be managed by inner HTML */
        }
        /* Style for main numbered items and aligned sub-headers */
        .assistant-message p.main-item {
            padding-left: 1em; /* Thụt đầu dòng 1 tab */
            margin-top: 1rem; /* Margin trên cho khoảng cách */
        }
        /* Style for content lines that are NOT sub-headers or main items, now 2em */
        .assistant-message p.content-line {
            padding-left: 2em; /* Thụt đầu dòng 2 tab */
            margin-top: 0.25rem; 
        }
        /* Style for sub-items with hyphens, now 2em with a small margin for bullet point */
        .assistant-message p.sub-item-hyphen {
            padding-left: 2em; /* Align with content-line depth */
            margin-top: 0.25rem;
        }
        /* Ensure the very first paragraph in the assistant message doesn't have top margin */
        .assistant-message p:first-child {
            margin-top: 0 !important;
        }


        .assistant-loading-text {
            font-style: italic;
            color: #8D6E63;
        }
        .assistant-loading-spinner {
            border: 3px solid rgba(141, 110, 99, 0.1);
            border-top: 3px solid #8D6E63;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px;
        }

        #chat-input-container {
            display: flex;
            width: 100%;
            gap: 0.5rem;
            margin-top: 1rem; /* Space from assistant message */
            align-items: center; /* Căn giữa các item theo chiều dọc */
        }
        #user-chat-input {
            flex-grow: 1; /* Cho phép input chiếm hết không gian có thể */
            padding: 0.75rem 1rem;
            border: 1px solid #b0c7d8;
            border-radius: 0.75rem;
            font-family: 'Quicksand', sans-serif;
            font-size: 0.95rem;
            background-color: #fcfdfe;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            min-width: 0; /* Cho phép input co lại nếu cần */
        }
        #user-chat-input:focus {
            outline: none;
            border-color: #8D6E63;
            box-shadow: 0 0 0 3px rgba(141, 110, 99, 0.2);
        }
        #send-chat-btn {
            padding: 0.75rem 1.25rem;
            background-color: #8D6E63;
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s ease, transform 0.1s ease;
            flex-shrink: 0; /* Ngăn nút co lại */
        }
        #send-chat-btn:hover {
            background-color: #7A5D4D;
            transform: translateY(-1px);
        }
        #send-chat-btn:active {
            transform: translateY(0);
        }
        #send-chat-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

    </style>
</head>
<body>
    <div id="vto-container">
        <h1 class="text-3xl font-bold text-brand mb-4">
            Thử Son Ảo - Sắc Mộc
        </h1>
        
        <div id="vto-video-container">
            <img id="vto-face-static" src="https://placehold.co/600x400/EFEBE9/8D6E63?text=Xem+trước+tĩnh" alt="Khuôn mặt mẫu" class="hidden">
            <video id="vto-video" playsinline autoplay muted></video>
            <canvas id="vto-canvas"></canvas>
            <div id="vto-lips-overlay" class="hidden"></div>
            <p id="vto-status"><span class="spinner"></span> Đang tải...</p>
        </div>

        <div id="vto-controls">
            <h4 class="font-semibold text-gray-700">Chọn màu son của bạn:</h4>
            <div id="vto-color-options">
            </div>
            
            <!-- Custom Color Picker Button is now moved to the bottom -->
            <button id="custom-color-btn" class="w-full mt-4">
                Trải nghiệm màu son của riêng bạn
            </button>

            <div class="mt-2 p-3 bg-amber-100 border-l-4 border-amber-500 text-amber-700 text-sm w-full rounded">
                <p><strong>Lưu ý:</strong> Để có kết quả tốt nhất, hãy đảm bảo khuôn mặt bạn được chiếu sáng đủ và nhìn thẳng vào webcam.</p>
                <p id="vto-fallback-note" class="hidden mt-1">Chế độ xem trước AI không khả dụng, đang hiển thị bản xem trước tĩnh.</p>
            </div>
        </div>
        
        <!-- NEW Color Picker Modal -->
        <div id="color-picker-modal" class="hidden">
            <div class="color-picker-content">
                <h4>Chọn màu son tùy chỉnh</h4>
                
                <div class="color-picker-ui">
                    <div class="color-palette-container">
                        <canvas id="color-palette-canvas" class="color-palette-canvas"></canvas>
                    </div>
                    <div class="color-slider-container">
                        <canvas id="color-slider-canvas" class="color-slider-canvas"></canvas>
                    </div>
                    <div class="picker-controls">
                         <span class="hex-code-display" id="hex-code-display">#FF4500</span>
                         <!-- NEW: Color preview box -->
                         <div id="color-preview-box" class="color-preview-box"></div>
                         <div class="flex-grow"></div> <!-- spacer -->
                         <button id="picker-done-btn" class="picker-done-btn">Hoàn thành</button>
                         <button id="picker-cancel-btn" class="picker-cancel-btn">Hủy</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Assistant Chatbox -->
        <div id="assistant-chatbox" class="mt-4">
            <h3>
                <img src="https://placehold.co/32x32/8D6E63/FFFFFF?text=AI" alt="Sắc Mộc Logo" class="h-8 w-auto rounded-full avatar-pulse" /> 
                Trợ lý ảo Sắc Mộc
            </h3>
            <div class="assistant-message-container">
                <p class="assistant-message" id="assistant-message">Chào mừng bạn đến với Sắc Mộc! Vui lòng nhìn thẳng vào webcam để tôi xác định sắc tố da và tư vấn màu son phù hợp nhất nhé.</p>
            </div>
            <div id="chat-input-container">
                <input type="text" id="user-chat-input" placeholder="Hỏi trợ lý Sắc Mộc..." disabled>
                <button id="send-chat-btn" disabled>Gửi</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Dynamically import MediaPipe Tasks Vision components
        const { FaceLandmarker, FilesetResolver } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js");

        const vtoVideo = document.getElementById('vto-video');
        const vtoCanvas = document.getElementById('vto-canvas');
        const vtoFaceStatic = document.getElementById('vto-face-static');
        const vtoLipsOverlay = document.getElementById('vto-lips-overlay');
        const vtoCtx = vtoCanvas.getContext('2d');
        const vtoColorOptions = document.getElementById('vto-color-options');
        const vtoStatus = document.getElementById('vto-status');
        const vtoFallbackNote = document.getElementById('vto-fallback-note');
        const assistantMessageElem = document.getElementById('assistant-message');
        const videoContainer = document.getElementById('vto-video-container'); // For glow effect
        const userChatInput = document.getElementById('user-chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');
        
        // NEW HTML element references for custom color picker
        const customColorBtn = document.getElementById('custom-color-btn');
        const colorPickerModal = document.getElementById('color-picker-modal');
        const pickerDoneBtn = document.getElementById('picker-done-btn');
        const pickerCancelBtn = document.getElementById('picker-cancel-btn');
        const colorPaletteCanvas = document.getElementById('color-palette-canvas');
        const colorSliderCanvas = document.getElementById('color-slider-canvas');
        const hexCodeDisplay = document.getElementById('hex-code-display');
        const colorPreviewBox = document.getElementById('color-preview-box');
        const paletteCtx = colorPaletteCanvas.getContext('2d');
        const sliderCtx = colorSliderCanvas.getContext('2d');
        
        let faceLandmarker;
        let currentLipColor = 'rgba(255, 69, 0, 0.7)'; // Default color: Đỏ Cam
        let targetLipColor = currentLipColor; // For smooth transitions
        let transitionStartTime = 0;
        const TRANSITION_DURATION = 300; // ms
        let videoStream;
        let animationFrameId;
        let advancedVtoAvailable = false;
        let lastVideoTime = -1;
        let currentSkinTone = null;
        let isSkinToneLocked = false;
        let lastComplimentIndex = -1;
        let assistantChatHistory = []; // To store chat history for conversational AI
        
        // NEW: Color Picker state variables
        let hue = 0;
        let saturation = 100;
        let lightness = 50;
        let isDraggingPalette = false;
        let isDraggingSlider = false;
        // Keep track of the current color for canceling
        let initialColorBeforePicker = ''; 

        // These landmark indices are standard for MediaPipe Face Mesh (478 landmarks model)
        // and should map to lips.
        const LIP_OUTLINE_UPPER = [61,185,40,39,37,0,267,269,270,409,291,308,415,310,311,312,13,82,81,80,191,78];
        const LIP_OUTLINE_LOWER = [61,146,91,181,84,17,314,405,321,375,291,324,318,402,317,14,87,178,88,95,78];

        // Landmark indices for a region on the forehead (for skin tone estimation)
        // These are approximations and might need fine-tuning.
        const FOREHEAD_LANDMARKS_SAMPLE = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 467, 441, 
            431, 319, 390, 462, 283, 300, 386, 397, 365, 379, 378, 400, 
            377, 152, 148, 176, 149, 150, 136, 172, 58, 207, 213, 215, 212, 
            214, 177, 199, 175, 171, 140, 170, 143, 145, 159, 160, 161
        ];

        // Pre-defined products with compliments - KHÔI PHỤC DỮ LIỆU SẢN PHẨM
        const products = [
            { 
                name: 'Đỏ Cam - 01', color: '#FF4500', 
                compliments: [
                    "Màu đỏ cam này trên môi bạn trông thật rạng rỡ và tràn đầy năng lượng!",
                    "Bạn thật sự nổi bật với sắc đỏ cam này, rất hợp với tông da của bạn!",
                    "Ôi, màu đỏ cam này làm bạn trông thật tươi tắn và cuốn hút!",
                    "Quyến rũ và hiện đại, màu đỏ cam này sinh ra để dành cho bạn!",
                    "Sự kết hợp giữa đỏ cam và khuôn mặt bạn thật hoàn hảo, rất cá tính!"
                ]
            },
            { 
                name: 'Cam Tươi - 02', color: '#FFA500',
                compliments: [
                    "Màu cam tươi này làm bừng sáng cả khuôn mặt bạn, rạng rỡ quá!",
                    "Bạn trông thật năng động và tươi trẻ với sắc cam tươi này!",
                    "Thật tuyệt vời, màu cam tươi này tôn lên vẻ đẹp ấm áp của bạn!",
                    "Đôi môi bạn như được thắp sáng với màu cam tươi đầy sức sống này!",
                    "Màu cam tươi này mang đến một vẻ ngoài đầy thu hút và phóng khoáng cho bạn!"
                ]
            },
            { 
                name: 'Đỏ Hồng - 03', color: '#FF69B4',
                compliments: [
                    "Ngọt ngào và dịu dàng, màu đỏ hồng này thật sự rất hợp với bạn!",
                    "Bạn trông thật đáng yêu với sắc đỏ hồng tươi tắn này!",
                    "Màu đỏ hồng này khiến bạn trông thật tự nhiên và duyên dáng!",
                    "Thật dễ thương, màu đỏ hồng này làm gương mặt bạn thêm phần rạng rỡ!",
                    "Sự lựa chọn đỏ hồng này mang đến vẻ đẹp trong trẻo và thanh thoát cho bạn!"
                ]
            },
            { 
                name: 'Đỏ Cherry - 04', color: '#DC143C',
                compliments: [
                    "Sắc đỏ cherry này thật quyền lực trên đôi môi bạn!",
                    "Bạn trông thật lộng lẫy và quyến rạng rũ với màu đỏ cherry này!",
                    "Vẻ đẹp của bạn tỏa sáng với màu đỏ cherry đầy mê hoặc!",
                    "Màu đỏ cherry này khiến bạn trông thật tự tin và nổi bật!",
                    "Tuyệt vời, màu đỏ cherry này mang đến vẻ đẹp kiêu sa và sang trọng cho bạn!"
                ]
            },
            { 
                name: 'Hồng Cánh Sen - 05', color: '#FF007F',
                compliments: [
                    "Màu hồng cánh sen này làm bạn trông thật nhẹ nhàng và cuốn hút!",
                    "Bạn thật thanh lịch với sắc hồng cánh sen này!",
                    "Ôi, màu hồng cánh sen này rất hợp với bạn, vừa tự nhiên vừa sang trọng!",
                    "Vẻ đẹp tinh tế của bạn được tôn vinh với sắc hồng cánh sen này!",
                    "Sắc hồng cánh sen này mang đến sự dịu dàng và hiện đại cho khuôn mặt bạn!"
                ]
            },
            { 
                name: 'Cam Đất - 06', color: '#CD853F',
                compliments: [
                    "Màu cam đất này làm bạn trông thật cá tính và thời thượng!",
                    "Thật ấn tượng, sắc cam đất này mang đến vẻ đẹp trầm ấm và cuốn hút cho bạn!",
                    "Bạn thật sự phong cách với màu cam đất này!",
                    "Màu cam đất này tôn lên vẻ đẹp tự nhiên và mạnh mẽ của bạn!",
                    "Đôi môi bạn trở nên quyến rũ và bí ẩn hơn với sắc cam đất này!"
                ]
            },
            { 
                name: 'Hồng Cam - 07', color: '#FF7F50',
                compliments: [
                    "Bạn thật tươi tắn và đáng yêu với màu hồng cam này!",
                    "Màu hồng cam này làm khuôn mặt bạn bừng sáng đầy sức sống!",
                    "Sắc hồng cam này mang đến vẻ ngoài trẻ trung và ngọt ngào cho bạn!",
                    "Thật rạng rỡ, màu hồng cam này rất hợp với bạn!",
                    "Đôi môi bạn trông thật tự nhiên và quyến rũ với sắc hồng cam này!"
                ]
            },
            { 
                name: 'Đỏ Rượu Vang - 08', color: '#800020',
                compliments: [
                    "Màu đỏ rượu vang này trên môi bạn thật sự lôi cuốn và bí ẩn!",
                    "Bạn trông thật sang chảnh và đẳng cấp với sắc đỏ rượu vang này!",
                    "Vẻ đẹp huyền bí của bạn được tôn lên bởi màu đỏ rượu vang này!",
                    "Thật ma mị và quyến rũ, màu đỏ rượu vang này sinh ra để dành cho bạn!",
                    "Sắc đỏ rượu vang này mang đến một vẻ ngoài đầy mê hoặc và thời thượng cho bạn!"
                ]
            },
            { 
                name: 'Hồng Fuchsia - 09', color: '#C154C1',
                compliments: [
                    "Sắc hồng fuchsia này làm bạn trông thật nổi bật và cá tính!",
                    "Bạn thật sự tự tin và đầy sức sống với màu hồng fuchsia rực rỡ này!",
                    "Ôi, màu hồng fuchsia này khiến bạn trông thật phá cách và hiện đại!",
                    "Vẻ đẹp độc đáo của bạn được tôn vinh với sắc hồng fuchsia này!",
                    "Màu hồng fuchsia này mang đến một phong cách táo bạo và đầy cuốn hút cho bạn!"
                ]
            },
            { 
                name: 'Nude Đào - 10', color: '#F7CAC9',
                compliments: [
                    "Màu nude đào này làm bạn trông thật nhẹ nhàng và tinh khiết!",
                    "Bạn thật duyên dáng với sắc nude đào tự nhiên này!",
                    "Vẻ đẹp trong trẻo của bạn được tôn lên bởi màu nude đào này!",
                    "Thật thanh thoát, màu nude đào này rất hợp với bạn!",
                    "Sắc nude đào này mang đến sự thuần khiết và dịu dàng cho đôi môi bạn!"
                ]
            },
            { 
                name: 'Mận Chín - 11', color: '#8E4585',
                compliments: [
                    "Màu mận chín này trên môi bạn thật sự sang trọng và bí ẩn!",
                    "Bạn trông thật quý phái với sắc mận chín cuốn hút này!",
                    "Vẻ đẹp trưởng thành và quyến rũ của bạn được tôn vinh với màu mận chín!",
                    "Thật ấn tượng, màu mận chín này mang đến một vẻ ngoài đầy mê hoặc!",
                    "Sắc mận chín này khiến bạn trông thật tự tin và đầy quyền lực!"
                ]
            },
            { 
                name: 'Hồng Tím - 12', color: '#C8A2C8',
                compliments: [
                    "Sắc hồng tím này làm bạn trông thật độc đáo và nổi bật!",
                    "Bạn thật sự cá tính với màu hồng tím pha chút bí ẩn này!",
                    "Màu hồng tím này mang đến vẻ đẹp vừa dịu dàng vừa phá cách cho bạn!",
                    "Thật quyến rũ, màu hồng tím này tôn lên vẻ đẹp riêng của bạn!",
                    "Đôi môi bạn trông thật cuốn hút và khác biệt với sắc hồng tím này!"
                ]
            }
        ];

        // Populate color options
        products.forEach(p => {
            const colorBtn = document.createElement('button');
            colorBtn.className = 'vto-color-btn';
            colorBtn.style.backgroundColor = p.color;
            colorBtn.dataset.color = p.color;
            colorBtn.dataset.name = p.name; // Store product name
            colorBtn.setAttribute('aria-label', `Thử màu ${p.name}`);
            colorBtn.addEventListener('click', () => {
                const previousColor = currentLipColor; // Store current color before changing
                targetLipColor = hexToRgba(p.color, 0.7); // Set target color with alpha
                transitionStartTime = performance.now(); // Start transition timer

                // Remove 'active' class from all buttons and then add to the clicked one
                document.querySelectorAll('.vto-color-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('custom-color-btn').classList.remove('active'); // Remove active class from custom button
                colorBtn.classList.add('active');
                
                if (!advancedVtoAvailable) {
                    vtoLipsOverlay.style.backgroundColor = targetLipColor; // For static preview
                }

                // Only send compliment if the color actually changed
                if (targetLipColor !== previousColor) {
                    sendCompliment(p.name); 
                }

                // Vibrate for haptic feedback on mobile
                if (navigator.vibrate) {
                    navigator.vibrate(50); // Vibrate for 50ms
                }
            });
            vtoColorOptions.appendChild(colorBtn);
        });

        // Set the first product as active on load WITHOUT sending a compliment
        if (vtoColorOptions.firstElementChild) {
            vtoColorOptions.firstElementChild.classList.add('active');
            currentLipColor = hexToRgba(products[0].color, 0.7); // Manually set default color
            targetLipColor = currentLipColor; // Initialize target color
            if (!advancedVtoAvailable) { // For static preview mode
                vtoLipsOverlay.style.backgroundColor = currentLipColor;
            }
        }

        // NEW: Color Picker logic
        
        // Function to convert HSL to a valid CSS color string
        function hslToCss(h, s, l) {
            return `hsl(${h}, ${s}%, ${l}%)`;
        }
        
        // Function to convert RGB to Hex
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // CORRECTED HSL to RGB conversion
        function hslToRgb(h, s, l) {
            s /= 100;
            l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs(((h / 60) % 2) - 1));
            const m = l - c / 2;
            let r = 0;
            let g = 0;
            let b = 0;
            if (0 <= h && h < 60) {
                r = c; g = x; b = 0;
            } else if (60 <= h && h < 120) {
                r = x; g = c; b = 0;
            } else if (120 <= h && h < 180) {
                r = 0; g = c; b = x;
            } else if (180 <= h && h < 240) {
                r = 0; g = x; b = c;
            } else if (240 <= h && h < 300) {
                r = x; g = 0; b = c;
            } else if (300 <= h && h < 360) {
                r = c; g = 0; b = x;
            }
            r = Math.round((r + m) * 255);
            g = Math.round((g + m) * 255);
            b = Math.round((b + m) * 255);
            return [r, g, b];
        }

        function drawColorPalette() {
            paletteCtx.clearRect(0, 0, colorPaletteCanvas.width, colorPaletteCanvas.height);
            const baseColor = hslToCss(hue, 100, 50);

            // Draw saturation gradient (left to right)
            const saturationGradient = paletteCtx.createLinearGradient(0, 0, colorPaletteCanvas.width, 0);
            saturationGradient.addColorStop(0, '#FFFFFF'); // White
            saturationGradient.addColorStop(1, baseColor);
            paletteCtx.fillStyle = saturationGradient;
            paletteCtx.fillRect(0, 0, colorPaletteCanvas.width, colorPaletteCanvas.height);

            // Draw lightness gradient (top to bottom)
            const lightnessGradient = paletteCtx.createLinearGradient(0, 0, 0, colorPaletteCanvas.height);
            lightnessGradient.addColorStop(0, 'rgba(0,0,0,0)'); // Transparent
            lightnessGradient.addColorStop(1, '#000000'); // Black
            paletteCtx.fillStyle = lightnessGradient;
            paletteCtx.fillRect(0, 0, colorPaletteCanvas.width, colorPaletteCanvas.height);

            // Draw the marker
            const markerX = (saturation / 100) * colorPaletteCanvas.width;
            const markerY = (1 - (lightness / 100)) * colorPaletteCanvas.height;
            paletteCtx.beginPath();
            paletteCtx.arc(markerX, markerY, 8, 0, 2 * Math.PI);
            paletteCtx.strokeStyle = 'black';
            paletteCtx.lineWidth = 2;
            paletteCtx.stroke();
            paletteCtx.fillStyle = 'white';
            paletteCtx.fill();
        }

        function drawColorSlider() {
            sliderCtx.clearRect(0, 0, colorSliderCanvas.width, colorSliderCanvas.height);
            const gradient = sliderCtx.createLinearGradient(0, 0, 0, colorSliderCanvas.height);
            gradient.addColorStop(0, 'hsl(0, 100%, 50%)');
            gradient.addColorStop(0.17, 'hsl(60, 100%, 50%)');
            gradient.addColorStop(0.33, 'hsl(120, 100%, 50%)');
            gradient.addColorStop(0.5, 'hsl(180, 100%, 50%)');
            gradient.addColorStop(0.67, 'hsl(240, 100%, 50%)');
            gradient.addColorStop(0.83, 'hsl(300, 100%, 50%)');
            gradient.addColorStop(1, 'hsl(360, 100%, 50%)');
            sliderCtx.fillStyle = gradient;
            sliderCtx.fillRect(0, 0, colorSliderCanvas.width, colorSliderCanvas.height);
            
            const markerY = (hue / 360) * colorSliderCanvas.height;
            sliderCtx.beginPath();
            sliderCtx.arc(colorSliderCanvas.width / 2, markerY, 8, 0, 2 * Math.PI);
            sliderCtx.strokeStyle = 'black';
            sliderCtx.lineWidth = 2;
            sliderCtx.stroke();
            sliderCtx.fillStyle = 'white';
            sliderCtx.fill();
        }
        
        function handlePaletteSelection(e) {
            const rect = colorPaletteCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Corrected saturation mapping: from 0 (white) to 100% (base color)
            const newSaturation = Math.min(Math.max(x / colorPaletteCanvas.width, 0), 1) * 100;
            // Corrected lightness mapping: from 100% (top) to 0% (bottom)
            const newLightness = (1 - Math.min(Math.max(y / colorPaletteCanvas.height, 0), 1)) * 100;
            
            saturation = newSaturation;
            lightness = newLightness;

            updatePickerUI();
        }

        function handleSliderSelection(e) {
            const rect = colorSliderCanvas.getBoundingClientRect();
            const y = e.clientY - rect.top;
            
            const newHue = Math.min(Math.max(y / colorSliderCanvas.height, 0), 1) * 360;
            
            hue = newHue;

            drawColorPalette(); // Redraw palette with the new hue
            updatePickerUI();
        }

        function updatePickerUI() {
            const rgb = hslToRgb(hue, saturation, lightness);
            const hex = rgbToHex(rgb[0], rgb[1], rgb[2]);
            hexCodeDisplay.textContent = hex.toUpperCase();
            colorPreviewBox.style.backgroundColor = hex;

            drawColorPalette();
            drawColorSlider();

            if (advancedVtoAvailable) {
                targetLipColor = hexToRgba(hex, 0.7);
            } else {
                vtoLipsOverlay.style.backgroundColor = hexToRgba(hex, 0.7);
            }
        }
        
        function initializeColorPicker() {
            const paletteRect = colorPaletteCanvas.getBoundingClientRect();
            colorPaletteCanvas.width = paletteRect.width;
            colorPaletteCanvas.height = paletteRect.height;
            const sliderRect = colorSliderCanvas.getBoundingClientRect();
            colorSliderCanvas.width = sliderRect.width;
            colorSliderCanvas.height = paletteRect.height;

            drawColorPalette();
            drawColorSlider();
            updatePickerUI();
        }

        window.addEventListener('resize', initializeColorPicker);

        customColorBtn.addEventListener('click', () => {
            colorPickerModal.classList.remove('hidden');
            initialColorBeforePicker = currentLipColor;
            document.querySelectorAll('.vto-color-btn').forEach(btn => btn.classList.remove('active'));
            customColorBtn.classList.add('active');
            
            initializeColorPicker();
        });

        pickerDoneBtn.addEventListener('click', () => {
            const newColor = hexCodeDisplay.textContent;
            targetLipColor = hexToRgba(newColor, 0.7);
            transitionStartTime = performance.now();
            colorPickerModal.classList.add('hidden');
            if (!advancedVtoAvailable) {
                vtoLipsOverlay.style.backgroundColor = targetLipColor; 
            }
            sendCompliment('màu tùy chỉnh'); 
        });

        pickerCancelBtn.addEventListener('click', () => {
            colorPickerModal.classList.add('hidden');
            targetLipColor = initialColorBeforePicker;
            transitionStartTime = performance.now();
            if (!advancedVtoAvailable) {
                vtoLipsOverlay.style.backgroundColor = targetLipColor;
            }
            document.querySelectorAll('.vto-color-btn').forEach(btn => {
                const hexColor = targetLipColor.match(/^rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d\.]+)\)$/);
                if (hexColor) {
                    const r = parseInt(hexColor[1]);
                    const g = parseInt(hexColor[2]);
                    const b = parseInt(hexColor[3]);
                    const hexFromRgb = "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
                    if (btn.dataset.color.toUpperCase() === hexFromRgb) {
                        btn.classList.add('active');
                        document.getElementById('custom-color-btn').classList.remove('active');
                    }
                }
            });
        });

        function startDraggingPalette(e) {
            isDraggingPalette = true;
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            handlePaletteSelection(touch);
        }

        function dragPalette(e) {
            if (isDraggingPalette) {
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                handlePaletteSelection(touch);
            }
        }

        function stopDraggingPalette() {
            isDraggingPalette = false;
        }

        colorPaletteCanvas.addEventListener('mousedown', startDraggingPalette);
        colorPaletteCanvas.addEventListener('mousemove', dragPalette);
        window.addEventListener('mouseup', stopDraggingPalette);
        colorPaletteCanvas.addEventListener('touchstart', startDraggingPalette);
        colorPaletteCanvas.addEventListener('touchmove', dragPalette);
        colorPaletteCanvas.addEventListener('touchend', stopDraggingPalette);

        function startDraggingSlider(e) {
            isDraggingSlider = true;
            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            handleSliderSelection(touch);
        }

        function dragSlider(e) {
            if (isDraggingSlider) {
                e.preventDefault();
                const touch = e.touches ? e.touches[0] : e;
                handleSliderSelection(touch);
            }
        }

        function stopDraggingSlider() {
            isDraggingSlider = false;
        }

        colorSliderCanvas.addEventListener('mousedown', startDraggingSlider);
        colorSliderCanvas.addEventListener('mousemove', dragSlider);
        window.addEventListener('mouseup', stopDraggingSlider);
        colorSliderCanvas.addEventListener('touchstart', startDraggingSlider);
        colorSliderCanvas.addEventListener('touchmove', dragSlider);
        colorSliderCanvas.addEventListener('touchend', stopDraggingSlider);
        
        async function setupWebcam() {
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }, 
                    audio: false 
                });
                vtoVideo.srcObject = videoStream;
                return new Promise((resolve) => {
                    vtoVideo.onloadedmetadata = () => {
                        vtoVideo.play().then(() => {
                           resolve(true);
                        }).catch(e => {
                           console.error("Error auto-playing video:", e);
                           resolve(false);
                        });
                    }
                    vtoVideo.onerror = () => {
                        console.error("Video error.");
                        resolve(false);
                    }
                });
            } catch (err) {
                console.error("Error accessing webcam:", err);
                vtoStatus.innerHTML = '<span class="spinner"></span> Không thể truy cập webcam. Vui lòng cấp quyền.';
                advancedVtoAvailable = false;
                return false;
            }
        }
        
        async function createFaceLandmarker() {
            vtoStatus.innerHTML = '<span class="spinner"></span> Đang khởi tạo AI...';
            advancedVtoAvailable = false;
            try {
                const filesetResolver = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
                );
                faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: false,
                    outputFacialTransformationMatrixes: false,
                    runningMode: "VIDEO",
                    numFaces: 1
                });
                console.log("FaceLandmarker created successfully.");
                advancedVtoAvailable = true;
                return true;
            } catch (error) {
                console.error("Lỗi khi tạo FaceLandmarker:", error);
                vtoStatus.innerHTML = '<span class="spinner"></span> Lỗi khởi tạo AI. Chuyển sang xem trước tĩnh.';
                advancedVtoAvailable = false;
                return false;
            }
        }
        
        function hexToRgba(hex, alpha = 0.7) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function rgbaToArray(rgba) {
            const parts = rgba.match(/\d+(\.\d+)?/g).map(Number);
            return [parts[0], parts[1], parts[2], parts[3]];
        }

        function arrayToRgba([r, g, b, a]) {
            return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;
        }

        function interpolateColor(color1, color2, t) {
            const c1 = rgbaToArray(color1);
            const c2 = rgbaToArray(color2);
            const r = c1[0] * (1 - t) + c2[0] * t;
            const g = c1[1] * (1 - t) + c2[1] * t;
            const b = c1[2] * (1 - t) + c2[2] * t;
            const a = c1[3] * (1 - t) + c2[3] * t;
            return arrayToRgba([r, g, b, a]);
        }

        function activateStaticPreview() {
            console.log("Activating static preview mode.");
            vtoVideo.classList.add('hidden');
            vtoCanvas.classList.add('hidden');
            videoContainer.classList.remove('face-detected');
            vtoFaceStatic.classList.remove('hidden');
            vtoLipsOverlay.classList.remove('hidden');
            vtoLipsOverlay.style.backgroundColor = currentLipColor;
            vtoStatus.innerHTML = '<span class="spinner"></span> Xem trước tĩnh (AI không khả dụng).';
            vtoStatus.style.display = 'flex';
            vtoFallbackNote.classList.remove('hidden');
            userChatInput.disabled = true;
            sendChatBtn.disabled = true;

            if (videoStream) {
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
                vtoVideo.srcObject = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function activateAdvancedPreview() {
            console.log("Attempting to activate advanced preview mode.");
            vtoFaceStatic.classList.add('hidden');
            vtoLipsOverlay.classList.add('hidden');
            vtoVideo.classList.remove('hidden');
            vtoCanvas.classList.remove('hidden');
            vtoFallbackNote.classList.add('hidden');
            vtoStatus.innerHTML = '<span class="spinner"></span> Đang nhận diện...';
            userChatInput.disabled = false;
            sendChatBtn.disabled = false;
        }

        function drawLipstick(landmarks) {
            const now = performance.now();
            let interpolatedColor = currentLipColor;

            if (currentLipColor !== targetLipColor) {
                const elapsed = now - transitionStartTime;
                const t = Math.min(elapsed / TRANSITION_DURATION, 1);
                interpolatedColor = interpolateColor(currentLipColor, targetLipColor, t);
                if (t >= 1) {
                    currentLipColor = targetLipColor;
                }
            } else {
                interpolatedColor = currentLipColor;
            }

            vtoCtx.clearRect(0, 0, vtoCanvas.width, vtoCanvas.height);
            if (!landmarks || landmarks.length === 0) {
                return;
            }

            vtoCtx.fillStyle = interpolatedColor;

            vtoCtx.beginPath();
            const upperLipPoints = LIP_OUTLINE_UPPER.map(idx => ({
                x: (1 - landmarks[idx].x) * vtoCanvas.width, 
                y: landmarks[idx].y * vtoCanvas.height
            }));
            vtoCtx.moveTo(upperLipPoints[0].x, upperLipPoints[0].y);
            for (let i = 1; i < upperLipPoints.length; i++) {
                vtoCtx.lineTo(upperLipPoints[i].x, upperLipPoints[i].y);
            }
            vtoCtx.closePath();
            vtoCtx.fill();

            vtoCtx.beginPath();
            const lowerLipPoints = LIP_OUTLINE_LOWER.map(idx => ({
                x: (1 - landmarks[idx].x) * vtoCanvas.width, 
                y: landmarks[idx].y * vtoCanvas.height
            }));
            vtoCtx.moveTo(lowerLipPoints[0].x, lowerLipPoints[0].y);
            for (let i = 1; i < lowerLipPoints.length; i++) {
                vtoCtx.lineTo(lowerLipPoints[i].x, lowerLipPoints[i].y);
            }
            vtoCtx.closePath();
            vtoCtx.fill();
            
            vtoStatus.style.display = 'none';
            videoContainer.classList.add('face-detected');
        }

        function estimateSkinTone(landmarks) {
            if (!landmarks || landmarks.length === 0) {
                return null;
            }

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = vtoVideo.videoWidth;
            tempCanvas.height = vtoVideo.videoHeight;
            
            tempCtx.drawImage(vtoVideo, 0, 0, tempCanvas.width, tempCanvas.height);

            let sampleX, sampleY;
            const centralForeheadLandmarkIndex = 10;
            if (landmarks[centralForeheadLandmarkIndex]) {
                sampleX = (1 - landmarks[centralForeheadLandmarkIndex].x) * tempCanvas.width; 
                sampleY = landmarks[centralForeheadLandmarkIndex].y * tempCanvas.height;
            } else {
                sampleX = tempCanvas.width / 2;
                sampleY = tempCanvas.height / 4; 
            }
            
            const imageData = tempCtx.getImageData(sampleX, sampleY, 1, 1).data;
            const r = imageData[0];
            const g = imageData[1];
            const b = imageData[2];

            const brightness = (r + g + b) / 3;
            let tone = "trung tính";

            if (r > 200 && g > 180 && b > 160) {
                tone += " sáng";
            } else if (r > 150 && g > 120 && b > 100) {
                tone += " trung bình";
            } else {
                tone += " tối";
            }

            if (b > r && b > g) {
                tone += " lạnh";
            } else if (r > g && g > b) {
                tone += " ấm";
            } else {
                tone += " trung tính";
            }
            
            return tone.trim();
        }

        async function getGeminiResponse(prompt, isUserInitiated = false) {
            assistantMessageElem.innerHTML = '<span class="assistant-loading-spinner"></span> <span class="assistant-loading-text">Trợ lý ảo đang suy nghĩ...</span>';
            userChatInput.disabled = true;
            sendChatBtn.disabled = true;

            if (isUserInitiated) {
                assistantChatHistory.push({ role: "user", parts: [{ text: prompt }] });
            }

            const payload = { contents: assistantChatHistory };
            const apiKey = "AIzaSyCZZH7f4IHZ_6WpyW03Az7N7qA_ci1x7qM"; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    console.error("Gemini API HTTP Error:", errorBody);
                    throw new Error(`Lỗi HTTP: ${response.status}. Chi tiết: ${errorBody.substring(0, 100)}...`);
                }

                let result;
                try {
                    result = await response.json();
                } catch (jsonError) {
                    console.error("Lỗi phân tích cú pháp JSON từ Gemini API:", jsonError);
                    const rawText = await response.text();
                    console.error("Phản hồi thô từ Gemini API:", rawText);
                    throw new Error("Lỗi: Không thể đọc phản hồi từ trợ lý ảo.");
                }
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    assistantChatHistory.push({ role: "model", parts: [{ text: text }] });
                    return text;
                } else {
                    console.error("Gemini API returned an unexpected structure or no content:", result);
                    throw new Error("Xin lỗi, tôi không thể tạo phản hồi lúc này. Cấu trúc phản hồi không mong muốn.");
                }
            }
            catch (error) {
                console.error("Lỗi khi gọi Gemini API:", error);
                return "Đã xảy ra lỗi khi kết nối với trợ lý ảo. Vui lòng kiểm tra kết nối mạng và bảng điều khiển.";
            } finally {
                userChatInput.disabled = false;
                sendChatBtn.disabled = false;
                assistantMessageElem.querySelector('.assistant-loading-spinner')?.remove();
                assistantMessageElem.querySelector('.assistant-loading-text')?.remove();
            }
        }

        async function recommendLipstick(skinTone) {
            const productNames = products.map(p => p.name).join(', ');
            const prompt = `Tôi có sắc tố da mặt là "${skinTone}". Hãy gợi ý cho tôi 3 màu son trong danh sách sau đây (${productNames}) mà phù hợp nhất với sắc tố da của tôi. Ngoài ra, hãy gợi ý thêm một phong cách trang điểm hoặc phối đồ phù hợp với mỗi màu son đó, và một dịp sử dụng thích hợp. Định dạng câu trả lời của bạn là một danh sách được đánh số rõ ràng, mỗi mục là một màu son gợi ý. Đảm bảo toàn bộ dòng của mục được đánh số (ví dụ: "1. Tên Son - Mã số:") được in đậm. Chỉ riêng từ "Giải thích:" (hoặc "Lý do:", "Phong cách trang điểm:", "Phối đồ:", "Dịp sử dụng:", "Lưu ý:") được in đậm mà không phải toàn bộ phần nội dung theo sau. Các tiêu đề con này cũng phải gióng thẳng hàng với số mục chính. Các ý con trong "Phong cách trang điểm:" và "Phối đồ:" hãy bắt đầu bằng dấu gạch ngang "-". Đảm bảo có đủ dấu cách giữa các từ.`;
            assistantChatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            let recommendation = await getGeminiResponse(prompt);
            
            recommendation = recommendation.replace(/"/g, '').replace(/\*/g, ''); 

            let formattedHtml = '';
            const lines = recommendation.split('\n');

            let currentSectionType = '';
            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine.length === 0) {
                    formattedHtml += '<p></p>';
                    return;
                }

                if (trimmedLine.match(/^\d+\.\s/)) {
                    const match = trimmedLine.match(/^(\d+\.\s)(.*)/);
                    if (match && match.length >= 3) {
                        formattedHtml += `<p class="main-item"><strong>${match[1]}${match[2]}</strong></p>`;
                    } else {
                        formattedHtml += `<p class="main-item"><strong>${trimmedLine}</strong></p>`;
                    }
                    currentSectionType = '';
                } 
                else if (trimmedLine.match(/^(Giải thích:|Phong cách trang điểm:|Phối đồ:|Dịp sử dụng:|Lưu ý:)/)) {
                    const headerMatch = trimmedLine.match(/^(Giải thích:|Phong cách trang điểm:|Phối đồ:|Dịp sử dụng:|Lưu ý:)\s*(.*)/);
                    if (headerMatch) {
                        const boldPart = headerMatch[1];
                        const restOfLine = headerMatch[2];

                        formattedHtml += `<p class="main-item"><strong>${boldPart}</strong>${restOfLine ? ' ' + restOfLine : ''}</p>`;
                    } else {
                        formattedHtml += `<p class="main-item"><strong>${trimmedLine}</strong></p>`;
                    }
                    if (trimmedLine.includes('Phong cách trang điểm:')) {
                        currentSectionType = 'makeup';
                    } else if (trimmedLine.includes('Phối đồ:')) {
                        currentSectionType = 'outfit';
                    } else {
                        currentSectionType = '';
                    }
                } 
                else {
                    let contentToDisplay = trimmedLine;
                    let className = "content-line";

                    if ((currentSectionType === 'makeup' || currentSectionType === 'outfit') && !trimmedLine.startsWith('- ')) {
                         contentToDisplay = `- ${trimmedLine}`;
                         className = "sub-item-hyphen";
                    }
                    formattedHtml += `<p class="${className}">${contentToDisplay}</p>`;
                }
            });

            assistantMessageElem.innerHTML = formattedHtml;
            assistantMessageElem.style.textAlign = 'left';
            assistantMessageElem.style.whiteSpace = 'normal';
        }

        function sendCompliment(productName) {
            assistantMessageElem.innerHTML = '<span class="assistant-loading-spinner"></span> <span class="assistant-loading-text">Trợ lý ảo đang suy nghĩ...</span>';
            
            setTimeout(() => {
                if(productName === 'màu tùy chỉnh') {
                     assistantMessageElem.textContent = "Một sự lựa chọn đầy cá tính! Màu son này thật sự rất riêng và hợp với phong cách của bạn!";
                     assistantMessageElem.style.textAlign = 'center';
                     return;
                }

                const product = products.find(p => p.name === productName);
                if (!product || !product.compliments || product.compliments.length === 0) {
                    assistantMessageElem.textContent = "Bạn chọn màu này đẹp quá!";
                    assistantMessageElem.style.textAlign = 'center';
                    return;
                }

                let newComplimentIndex;
                do {
                    newComplimentIndex = Math.floor(Math.random() * product.compliments.length);
                } while (newComplimentIndex === lastComplimentIndex && product.compliments.length > 1);
                
                lastComplimentIndex = newComplimentIndex;
                assistantMessageElem.textContent = product.compliments[newComplimentIndex];
                assistantMessageElem.style.textAlign = 'center';
            }, 400);
        }

        async function handleUserChat() {
            const userQuery = userChatInput.value.trim();
            if (!userQuery) return;

            userChatInput.value = '';
            assistantMessageElem.innerHTML = '<span class="assistant-loading-spinner"></span> <span class="assistant-loading-text">Trợ lý ảo đang phản hồi...</span>';
            userChatInput.disabled = true;
            sendChatBtn.disabled = true;

            const response = await getGeminiResponse(userQuery, true);
            assistantMessageElem.innerHTML = `<p class="content-line">${response.trim().replace(/\*/g, '')}</p>`;
            assistantMessageElem.style.textAlign = 'left';
            assistantMessageElem.style.whiteSpace = 'normal';
            userChatInput.disabled = false;
            sendChatBtn.disabled = false;
            userChatInput.focus();
        }

        sendChatBtn.addEventListener('click', handleUserChat);
        userChatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                handleUserChat();
            }
        });


        async function detectionLoop() {
            if (!advancedVtoAvailable || !faceLandmarker) {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                if (!advancedVtoAvailable) activateStaticPreview();
                return;
            }

            if (vtoVideo.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA && !vtoVideo.paused && !vtoVideo.ended) {
                if (vtoVideo.videoWidth > 0 && vtoVideo.videoHeight > 0) {
                    if (vtoCanvas.width !== vtoVideo.videoWidth || vtoCanvas.height !== vtoVideo.videoHeight) {
                        vtoCanvas.width = vtoVideo.videoWidth;
                        vtoCanvas.height = vtoVideo.videoHeight;
                        console.log(`Canvas dimensions updated to: ${vtoCanvas.width}x${vtoCanvas.height}`);
                    }

                    const currentTime = performance.now();
                    if (vtoVideo.currentTime !== lastVideoTime) { 
                        lastVideoTime = vtoVideo.currentTime;
                        try {
                            const faceLandmarkerResult = faceLandmarker.detectForVideo(vtoVideo, currentTime);
                            
                            if (faceLandmarkerResult && faceLandmarkerResult.faceLandmarks && faceLandmarkerResult.faceLandmarks.length > 0) {
                                drawLipstick(faceLandmarkerResult.faceLandmarks[0]);
                                vtoStatus.style.display = 'none';
                                videoContainer.classList.add('face-detected');

                                const newSkinTone = estimateSkinTone(faceLandmarkerResult.faceLandmarks[0]);
                                if (newSkinTone && !isSkinToneLocked) {
                                    currentSkinTone = newSkinTone;
                                    isSkinToneLocked = true;
                                    console.log("Estimated and locked skin tone:", currentSkinTone);
                                    recommendLipstick(currentSkinTone);
                                }

                            } else {
                                vtoCtx.clearRect(0, 0, vtoCanvas.width, vtoCanvas.height);
                                vtoStatus.innerHTML = '<span class="spinner"></span> Không tìm thấy khuôn mặt.';
                                vtoStatus.style.display = 'flex';
                                videoContainer.classList.remove('face-detected');
                            }
                        } catch (error) {
                            console.error("Lỗi trong quá trình nhận diện khuôn mặt (MediaPipe):", error);
                            vtoStatus.innerHTML = '<span class="spinner"></span> Lỗi nhận diện. Thử lại.';
                            vtoStatus.style.display = 'flex';
                            videoContainer.classList.remove('face-detected');
                        }
                    }
                }
            }
            animationFrameId = requestAnimationFrame(detectionLoop);
        }

        async function startVTO() {
            console.log("Starting VTO initialization...");
            vtoStatus.innerHTML = '<span class="spinner"></span> Đang tải...';
            advancedVtoAvailable = await createFaceLandmarker();

            if (!advancedVtoAvailable) {
                console.log("Khởi tạo AI thất bại. Chuyển sang xem trước tĩnh.");
                activateStaticPreview();
                return;
            }
            
            const webcamReady = await setupWebcam();
            if (!webcamReady) {
                console.log("Không thể khởi động webcam. Chuyển sang xem trước tĩnh.");
                advancedVtoAvailable = false;
                activateStaticPreview();
                return;
            }
            
            activateAdvancedPreview();
            console.log("VTO nâng cao đã sẵn sàng. Bắt đầu vòng lặp nhận diện.");
            
            vtoVideo.oncanplay = () => {
                if (advancedVtoAvailable) {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    lastVideoTime = -1;
                    detectionLoop();
                }
            };
            if (vtoVideo.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA && !vtoVideo.paused) {
                 if (advancedVtoAvailable) {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    lastVideoTime = -1;
                    detectionLoop();
                }
            }
        }
        
        setTimeout(startVTO, 100);

    </script>
</body>
</html>
