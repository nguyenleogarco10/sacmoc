<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sắc Mộc - Thử Son Ảo Nâng Cấp </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js"></script>
    <style>
        body {
            font-family: 'Quicksand', sans-serif;
            background-color: #FDFBF8; /* Nền nhẹ nhàng, ấm áp */
            color: #4A4A4A;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 1.5rem; /* Tăng padding tổng thể */
            box-sizing: border-box;
        }
        .text-brand { color: #8D6E63; } /* Màu nâu đất chủ đạo */

        #vto-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1.5rem; /* Tăng khoảng cách giữa các phần */
            padding: 2rem; /* Tăng padding bên trong container */
            background-color: white;
            border-radius: 1rem; /* Bo góc mềm mại hơn */
            box-shadow: 0 15px 30px -8px rgba(0,0,0,0.15), 0 8px 12px -4px rgba(0,0,0,0.08); /* Đổ bóng sâu hơn */
            width: 100%;
            max-width: 950px; /* Rộng hơn một chút */
        }
        #vto-video-container {
            position: relative;
            width: 100%;
            max-width: 550px; /* Rộng hơn */
            aspect-ratio: 4 / 3;
            background-color: #EFEBE9;
            border-radius: 0.75rem; /* Bo góc */
            overflow: hidden;
            border: 1px solid rgba(141, 110, 99, 0.2); /* Viền mềm mại */
            box-shadow: 0 5px 15px -3px rgba(0,0,0,0.1); /* Đổ bóng nhẹ */
            transition: box-shadow 0.3s ease-out, border-color 0.3s ease-out; /* Add transition for glow effect */
        }
        #vto-video-container.face-detected {
            box-shadow: 0 0 0 5px rgba(141, 110, 99, 0.5), 0 0 20px rgba(141, 110, 99, 0.3); /* Glowing effect */
            border-color: #8D6E63;
        }

        #vto-video, #vto-canvas, #vto-face-static {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #vto-video {
            transform: scaleX(-1); /* Mirror mode */
        }
        #vto-canvas {
            pointer-events: none;
            /* Transition for smoother color application (if applicable to canvas/overlay) */
            /* Note: Canvas drawing doesn't directly support CSS transitions on fillStyle, handled by JS */
        }
        #vto-lips-overlay {
             position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            clip-path: polygon(29% 62%, 35% 58%, 43% 56%, 50% 57%, 57% 56%, 65% 58%, 71% 62%, 65% 66%, 57% 68%, 50% 69%, 43% 68%, 35% 66%);
            transition: background-color 0.3s ease-in-out; /* For static preview */
        }
        #vto-controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem; /* Tăng khoảng cách */
            width: 100%;
            max-width: 550px;
        }
        #vto-color-options {
            display: grid;
            grid-template-columns: repeat(6, minmax(0, 1fr)); 
            gap: 0.85rem; /* Tăng khoảng cách giữa các nút màu */
            width: 100%;
            overflow-x: auto; /* Enable horizontal scroll for many items */
            padding-top: 0.75rem; /* Add padding to the top to prevent clipping of active border/shadow */
            padding-bottom: 0.5rem; /* Keep existing padding-bottom */
            padding-left: 0.75rem; /* NEW: Add padding to the left to prevent clipping */
            padding-right: 0.75rem; /* NEW: Add padding to the right to prevent clipping */
            -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        /* Hide scrollbar for aesthetic purposes */
        #vto-color-options::-webkit-scrollbar {
            display: none;
        }
        #vto-color-options {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        @media (max-width: 768px) {
            #vto-color-options {
                grid-template-columns: repeat(4, minmax(0, 1fr)); /* 4 cột trên tablet */
            }
        }
        @media (max-width: 480px) {
            #vto-color-options {
                grid-template-columns: repeat(3, minmax(0, 1fr)); /* 3 cột trên di động */
            }
        }
        .vto-color-btn {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 0.5rem; /* Bo góc nhiều hơn */
            border: 2px solid transparent;
            cursor: pointer;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, transform 0.1s ease-out; /* Thêm transition cho transform */
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); /* Đổ bóng nhẹ mặc định */
        }
        .vto-color-btn:hover {
            border-color: #8D6E63;
            box-shadow: 0 0 0 3px #D7CCC8; /* Hiệu ứng sáng viền mạnh hơn khi hover */
            transform: translateY(-2px); /* Hiệu ứng nổi nhẹ */
        }
        .vto-color-btn.active {
            border: 4px solid #8D6E63; /* Increased border to make it more prominent and ensure visibility */
            box-shadow: 0 0 0 5px #8D6E63; /* Slightly increased shadow spread */
            transform: scale(1.07); /* Slightly increased scale to give more room */
        }
        #vto-status {
            text-align: center;
            padding: 0.75rem 1.25rem; /* Tăng padding */
            background-color: rgba(255,255,255,0.9);
            border-radius: 0.5rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            font-size: 1rem;
            color: #555;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
            display: flex; /* Để căn giữa spinner */
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        .hidden {
            display: none !important;
        }

        /* Loading Spinner for VTO Status */
        .spinner {
            border: 4px solid rgba(141, 110, 99, 0.1);
            border-top: 4px solid #8D6E63;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Styles for the assistant chatbox */
        #assistant-chatbox {
            background-image: linear-gradient(to bottom right, #f0f4f7, #e6edf2); /* Gradient tinh tế */
            border: 1px solid #b0c7d8; /* Viền tinh tế hơn */
            border-radius: 1.25rem; /* Bo góc nhiều hơn */
            padding: 1.5rem; /* Tăng padding */
            margin-top: 2rem; /* Tăng margin top */
            width: 100%;
            max-width: 600px; /* Rộng hơn nữa */
            min-height: 120px; /* Taller */
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            text-align: center;
            box-shadow: 0 12px 25px -8px rgba(0,0,0,0.2), 0 6px 10px -3px rgba(0,0,0,0.12); /* Đổ bóng mạnh hơn */
            position: relative;
        }
        #assistant-chatbox h3 {
            font-size: 1.35rem; /* Lớn hơn một chút */
            font-weight: 700; /* Đậm hơn */
            color: #2a3c4a; /* Màu chữ tối hơn */
            margin-bottom: 1rem; /* Tăng khoảng cách dưới tiêu đề */
            display: flex;
            align-items: center;
            gap: 0.75rem; /* Tăng khoảng cách giữa icon và chữ */
        }
        /* Avatar animation */
        .avatar-pulse {
            animation: avatarPulse 2s infinite ease-in-out;
        }
        @keyframes avatarPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .assistant-message-container {
            flex-grow: 1; /* Allows it to take available space */
            width: 100%;
            display: flex;
            justify-content: center; /* Center message horizontally */
            align-items: flex-start; /* Align message to the top */
            padding-bottom: 1rem;
            min-height: 80px; /* Ensure space for messages */
        }

        .assistant-message {
            font-size: 1rem; /* Kích thước chữ lớn hơn */
            color: #333;
            line-height: 1.5; /* GIẢM GIÃN CÁCH DÒNG */
            text-align: left; /* THAY ĐỔI CĂN CHỈNH SANG TRÁI */
            white-space: pre-wrap; /* Bảo toàn xuống dòng */
            word-wrap: break-word; /* Đảm bảo từ dài xuống dòng */
            padding: 0 0.5rem; /* Padding ngang nhẹ để tránh chữ quá sát viền */
            max-width: 90%; /* Limit width for readability */
            margin: 0 auto; /* Center the text block */
        }
        .assistant-loading-text {
            font-style: italic;
            color: #8D6E63;
        }
        .assistant-loading-spinner {
            border: 3px solid rgba(141, 110, 99, 0.1);
            border-top: 3px solid #8D6E63;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px;
        }

        #chat-input-container {
            display: flex;
            width: 100%;
            gap: 0.5rem;
            margin-top: 1rem; /* Space from assistant message */
        }
        #user-chat-input {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #b0c7d8;
            border-radius: 0.75rem;
            font-family: 'Quicksand', sans-serif;
            font-size: 0.95rem;
            background-color: #fcfdfe;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        #user-chat-input:focus {
            outline: none;
            border-color: #8D6E63;
            box-shadow: 0 0 0 3px rgba(141, 110, 99, 0.2);
        }
        #send-chat-btn {
            padding: 0.75rem 1.25rem;
            background-color: #8D6E63;
            color: white;
            border: none;
            border-radius: 0.75rem;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s ease, transform 0.1s ease;
        }
        #send-chat-btn:hover {
            background-color: #7A5D4D;
            transform: translateY(-1px);
        }
        #send-chat-btn:active {
            transform: translateY(0);
        }
        #send-chat-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

    </style>
</head>
<body>
    <div id="vto-container">
        <h1 class="text-3xl font-bold text-brand mb-4">
            Thử Son Ảo - Sắc Mộc
        </h1>
        
        <div id="vto-video-container">
            <img id="vto-face-static" src="https://placehold.co/600x400/EFEBE9/8D6E63?text=Xem+trước+tĩnh" alt="Khuôn mặt mẫu" class="hidden">
            <video id="vto-video" playsinline autoplay muted></video>
            <canvas id="vto-canvas"></canvas>
            <div id="vto-lips-overlay" class="hidden"></div>
            <p id="vto-status"><span class="spinner"></span> Đang tải...</p>
        </div>

        <div id="vto-controls">
            <h4 class="font-semibold text-gray-700">Chọn màu son của bạn:</h4>
            <div id="vto-color-options"></div>
            <div class="mt-2 p-3 bg-amber-100 border-l-4 border-amber-500 text-amber-700 text-sm w-full rounded">
                <p><strong>Lưu ý:</strong> Để có kết quả tốt nhất, hãy đảm bảo khuôn mặt bạn được chiếu sáng đủ và nhìn thẳng vào webcam.</p>
                <p id="vto-fallback-note" class="hidden mt-1">Chế độ xem trước AI không khả dụng, đang hiển thị bản xem trước tĩnh.</p>
            </div>
        </div>

        <!-- Assistant Chatbox -->
        <div id="assistant-chatbox" class="mt-4">
            <h3>
                <img src="https://placehold.co/32x32/8D6E63/FFFFFF?text=AI" alt="Sắc Mộc Logo" class="h-8 w-auto rounded-full avatar-pulse" /> 
                Trợ lý ảo Sắc Mộc
            </h3>
            <div class="assistant-message-container">
                <p class="assistant-message" id="assistant-message">Chào mừng bạn đến với Sắc Mộc! Vui lòng nhìn thẳng vào webcam để tôi xác định sắc tố da và tư vấn màu son phù hợp nhất nhé.</p>
            </div>
            <div id="chat-input-container">
                <input type="text" id="user-chat-input" placeholder="Hỏi trợ lý Sắc Mộc..." disabled>
                <button id="send-chat-btn" disabled>Gửi</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Dynamically import MediaPipe Tasks Vision components
        const { FaceLandmarker, FilesetResolver } = await import("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js");

        const vtoVideo = document.getElementById('vto-video');
        const vtoCanvas = document.getElementById('vto-canvas');
        const vtoFaceStatic = document.getElementById('vto-face-static');
        const vtoLipsOverlay = document.getElementById('vto-lips-overlay');
        const vtoCtx = vtoCanvas.getContext('2d');
        const vtoColorOptions = document.getElementById('vto-color-options');
        const vtoStatus = document.getElementById('vto-status');
        const vtoFallbackNote = document.getElementById('vto-fallback-note');
        const assistantMessageElem = document.getElementById('assistant-message');
        const videoContainer = document.getElementById('vto-video-container'); // For glow effect
        const userChatInput = document.getElementById('user-chat-input');
        const sendChatBtn = document.getElementById('send-chat-btn');

        let faceLandmarker;
        let currentLipColor = 'rgba(185, 92, 80, 0.7)'; // Default color
        let targetLipColor = currentLipColor; // New: for smooth transitions
        let transitionStartTime = 0;
        const TRANSITION_DURATION = 300; // ms
        let videoStream;
        let animationFrameId;
        let advancedVtoAvailable = false;
        let lastVideoTime = -1;
        let currentSkinTone = null;
        let isSkinToneLocked = false;
        let lastComplimentIndex = -1;
        let assistantChatHistory = []; // To store chat history for conversational AI

        // These landmark indices are standard for MediaPipe Face Mesh (478 landmarks model)
        // and should map to lips.
        const LIP_OUTLINE_UPPER = [61,185,40,39,37,0,267,269,270,409,291,308,415,310,311,312,13,82,81,80,191,78];
        const LIP_OUTLINE_LOWER = [61,146,91,181,84,17,314,405,321,375,291,324,318,402,317,14,87,178,88,95,78];

        // Landmark indices for a region on the forehead (for skin tone estimation)
        // These are approximations and might need fine-tuning.
        const FOREHEAD_LANDMARKS_SAMPLE = [
            10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 467, 441, 
            431, 319, 390, 462, 283, 300, 386, 397, 365, 379, 378, 400, 
            377, 152, 148, 176, 149, 150, 136, 172, 58, 207, 213, 215, 212, 
            214, 177, 199, 175, 171, 140, 170, 143, 145, 159, 160, 161
        ];

        // Pre-defined products with compliments - KHÔI PHỤC DỮ LIỆU SẢN PHẨM
        const products = [
            { 
                name: 'Đỏ Đất - 01', color: '#B95C50', 
                compliments: [
                    "Màu đỏ đất này trên môi bạn trông thật sang trọng và cuốn hút!",
                    "Bạn thật sự nổi bật với sắc đỏ đất này, rất hợp với tông da của bạn!",
                    "Ôi, màu đỏ đất này làm bạn trông thật thanh lịch và hiện đại!",
                    "Quyến rũ và tinh tế, màu đỏ đất này sinh ra để dành cho bạn!",
                    "Sự kết hợp giữa đỏ đất và khuôn mặt bạn thật hoàn hảo, rất cá tính!"
                ]
            },
            { 
                name: 'Cam Cháy - 02', color: '#D87C4F',
                compliments: [
                    "Màu cam cháy này làm bừng sáng cả khuôn mặt bạn, rạng rỡ quá!",
                    "Bạn trông thật năng động và tươi trẻ với sắc cam cháy này!",
                    "Thật tuyệt vời, màu cam cháy này tôn lên vẻ đẹp ấm áp của bạn!",
                    "Đôi môi bạn như được thắp sáng với màu cam cháy đầy sức sống này!",
                    "Màu cam cháy này mang đến một vẻ ngoài đầy thu hút và phóng khoáng cho bạn!"
                ]
            },
            { 
                name: 'Hồng Đào - 03', color: '#E48F82',
                compliments: [
                    "Ngọt ngào và dịu dàng, màu hồng đào này thật sự rất hợp với bạn!",
                    "Bạn trông thật đáng yêu với sắc hồng đào tươi tắn này!",
                    "Màu hồng đào này khiến bạn trông thật tự nhiên và duyên dáng!",
                    "Thật dễ thương, màu hồng đào này làm gương mặt bạn thêm phần rạng rỡ!",
                    "Sự lựa chọn hồng đào này mang đến vẻ đẹp trong trẻo và thanh thoát cho bạn!"
                ]
            },
            { 
                name: 'Nâu Gỗ - 04', color: '#8C5A4D',
                compliments: [
                    "Màu nâu gỗ này làm bạn trông thật cá tính và thời thượng!",
                    "Thật ấn tượng, sắc nâu gỗ này mang đến vẻ đẹp trầm ấm và cuốn hút cho bạn!",
                    "Bạn thật sự phong cách với màu nâu gỗ này!",
                    "Màu nâu gỗ này tôn lên vẻ đẹp tự nhiên và mạnh mẽ của bạn!",
                    "Đôi môi bạn trở nên quyến rũ và bí ẩn hơn với sắc nâu gỗ này!"
                ]
            },
            { 
                name: 'Hồng Đất - 05', color: '#C68582',
                compliments: [
                    "Màu hồng đất này làm bạn trông thật nhẹ nhàng và cuốn hút!",
                    "Bạn thật thanh lịch với sắc hồng đất này!",
                    "Ôi, màu hồng đất này rất hợp với bạn, vừa tự nhiên vừa sang trọng!",
                    "Vẻ đẹp tinh tế của bạn được tôn vinh với màu hồng đất này!",
                    "Sắc hồng đất này mang đến sự dịu dàng và hiện đại cho khuôn mặt bạn!"
                ]
            },
            { 
                name: 'Đỏ Ruby - 06', color: '#9B1C1C',
                compliments: [
                    "Sắc đỏ ruby này thật quyền lực trên đôi môi bạn!",
                    "Bạn trông thật lộng lẫy và quyến rạng rũ với màu đỏ ruby này!",
                    "Vẻ đẹp của bạn tỏa sáng với màu đỏ ruby đầy mê hoặc!",
                    "Màu đỏ ruby này khiến bạn trông thật tự tin và nổi bật!",
                    "Tuyệt vời, màu đỏ ruby này mang đến vẻ đẹp kiêu sa và sang trọng cho bạn!"
                ]
            },
            { 
                name: 'Hồng Cam - 07', color: '#FF7F50',
                compliments: [
                    "Bạn thật tươi tắn và đáng yêu với màu hồng cam này!",
                    "Màu hồng cam này làm khuôn mặt bạn bừng sáng đầy sức sống!",
                    "Sắc hồng cam này mang đến vẻ ngoài trẻ trung và ngọt ngào cho bạn!",
                    "Thật rạng rỡ, màu hồng cam này rất hợp với bạn!",
                    "Đôi môi bạn trông thật tự nhiên và quyến rũ với sắc hồng cam này!"
                ]
            },
            { 
                name: 'Đỏ Rượu Vang - 08', color: '#800020',
                compliments: [
                    "Màu đỏ rượu vang này trên môi bạn thật sự lôi cuốn và bí ẩn!",
                    "Bạn trông thật sang chảnh và đẳng cấp với sắc đỏ rượu vang này!",
                    "Vẻ đẹp huyền bí của bạn được tôn lên bởi màu đỏ rượu vang này!",
                    "Thật ma mị và quyến rũ, màu đỏ rượu vang này sinh ra để dành cho bạn!",
                    "Sắc đỏ rượu vang này mang đến một vẻ ngoài đầy mê hoặc và thời thượng cho bạn!"
                ]
            },
            { 
                name: 'Hồng Fuchsia - 09', color: '#C154C1',
                compliments: [
                    "Sắc hồng fuchsia này làm bạn trông thật nổi bật và cá tính!",
                    "Bạn thật sự tự tin và đầy sức sống với màu hồng fuchsia rực rỡ này!",
                    "Ôi, màu hồng fuchsia này khiến bạn trông thật phá cách và hiện đại!",
                    "Vẻ đẹp độc đáo của bạn được tôn vinh với sắc hồng fuchsia này!",
                    "Màu hồng fuchsia này mang đến một phong cách táo bạo và đầy cuốn hút cho bạn!"
                ]
            },
            { 
                name: 'Nude Đào - 10', color: '#F7CAC9',
                compliments: [
                    "Màu nude đào này làm bạn trông thật nhẹ nhàng và tinh khiết!",
                    "Bạn thật duyên dáng với sắc nude đào tự nhiên này!",
                    "Vẻ đẹp trong trẻo của bạn được tôn lên bởi màu nude đào này!",
                    "Thật thanh thoát, màu nude đào này rất hợp với bạn!",
                    "Sắc nude đào này mang đến sự thuần khiết và dịu dàng cho đôi môi bạn!"
                ]
            },
            { 
                name: 'Mận Chín - 11', color: '#8E4585',
                compliments: [
                    "Màu mận chín này trên môi bạn thật sự sang trọng và bí ẩn!",
                    "Bạn trông thật quý phái với sắc mận chín cuốn hút này!",
                    "Vẻ đẹp trưởng thành và quyến rũ của bạn được tôn vinh với màu mận chín!",
                    "Thật ấn tượng, màu mận chín này mang đến một vẻ ngoài đầy mê hoặc!",
                    "Sắc mận chín này khiến bạn trông thật tự tin và đầy quyền lực!"
                ]
            },
            { 
                name: 'Hồng Tím - 12', color: '#C8A2C8',
                compliments: [
                    "Sắc hồng tím này làm bạn trông thật độc đáo và nổi bật!",
                    "Bạn thật sự cá tính với màu hồng tím pha chút bí ẩn này!",
                    "Màu hồng tím này mang đến vẻ đẹp vừa dịu dàng vừa phá cách cho bạn!",
                    "Thật quyến rũ, màu hồng tím này tôn lên vẻ đẹp riêng của bạn!",
                    "Đôi môi bạn trông thật cuốn hút và khác biệt với sắc hồng tím này!"
                ]
            }
        ];

        // Populate color options
        products.forEach(p => {
            const colorBtn = document.createElement('button');
            colorBtn.className = 'vto-color-btn';
            colorBtn.style.backgroundColor = p.color;
            colorBtn.dataset.color = p.color;
            colorBtn.dataset.name = p.name; // Store product name
            colorBtn.setAttribute('aria-label', `Thử màu ${p.name}`);
            colorBtn.addEventListener('click', () => {
                const previousColor = currentLipColor; // Store current color before changing
                targetLipColor = hexToRgba(p.color, 0.7); // Set target color with alpha
                transitionStartTime = performance.now(); // Start transition timer

                // Remove 'active' class from all buttons and then add to the clicked one
                document.querySelectorAll('.vto-color-btn').forEach(btn => btn.classList.remove('active'));
                colorBtn.classList.add('active');
                
                if (!advancedVtoAvailable) {
                    vtoLipsOverlay.style.backgroundColor = targetLipColor; // For static preview
                }

                // Only send compliment if the color actually changed
                if (targetLipColor !== previousColor) {
                    sendCompliment(p.name); 
                }

                // Vibrate for haptic feedback on mobile
                if (navigator.vibrate) {
                    navigator.vibrate(50); // Vibrate for 50ms
                }
            });
            vtoColorOptions.appendChild(colorBtn);
        });

        // Set the first product as active on load WITHOUT sending a compliment
        if (vtoColorOptions.firstElementChild) {
            vtoColorOptions.firstElementChild.classList.add('active');
            currentLipColor = hexToRgba(products[0].color, 0.7); // Manually set default color
            targetLipColor = currentLipColor; // Initialize target color
            if (!advancedVtoAvailable) { // For static preview mode
                vtoLipsOverlay.style.backgroundColor = currentLipColor;
            }
        }


        async function setupWebcam() {
            try {
                videoStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: 'user' }, 
                    audio: false 
                });
                vtoVideo.srcObject = videoStream;
                return new Promise((resolve) => {
                    vtoVideo.onloadedmetadata = () => {
                        vtoVideo.play().then(() => { // Autoplay after metadata is loaded
                           resolve(true);
                        }).catch(e => {
                           console.error("Error auto-playing video:", e);
                           resolve(false); // Could not play
                        });
                    }
                    vtoVideo.onerror = () => { // Handle video error
                        console.error("Video error.");
                        resolve(false);
                    }
                });
            } catch (err) {
                console.error("Error accessing webcam:", err);
                vtoStatus.innerHTML = '<span class="spinner"></span> Không thể truy cập webcam. Vui lòng cấp quyền.';
                advancedVtoAvailable = false;
                return false;
            }
        }
        
        async function createFaceLandmarker() {
            vtoStatus.innerHTML = '<span class="spinner"></span> Đang khởi tạo AI...';
            advancedVtoAvailable = false;
            try {
                const filesetResolver = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
                );
                faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU" // Or "CPU"
                    },
                    outputFaceBlendshapes: false, // Not needed for simple lipstick
                    outputFacialTransformationMatrixes: false, // Not needed
                    runningMode: "VIDEO", // Important for video processing
                    numFaces: 1
                });
                console.log("FaceLandmarker created successfully.");
                advancedVtoAvailable = true;
                return true;
            } catch (error) {
                console.error("Lỗi khi tạo FaceLandmarker:", error);
                vtoStatus.innerHTML = '<span class="spinner"></span> Lỗi khởi tạo AI. Chuyển sang xem trước tĩnh.';
                advancedVtoAvailable = false;
                return false;
            }
        }
        
        function hexToRgba(hex, alpha = 0.7) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Helper to convert rgba string to array [r, g, b, a]
        function rgbaToArray(rgba) {
            const parts = rgba.match(/\d+(\.\d+)?/g).map(Number);
            return [parts[0], parts[1], parts[2], parts[3]];
        }

        // Helper to convert array [r, g, b, a] to rgba string
        function arrayToRgba([r, g, b, a]) {
            return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${a})`;
        }

        function interpolateColor(color1, color2, t) {
            const c1 = rgbaToArray(color1);
            const c2 = rgbaToArray(color2);
            const r = c1[0] * (1 - t) + c2[0] * t;
            const g = c1[1] * (1 - t) + c2[1] * t;
            const b = c1[2] * (1 - t) + c2[2] * t;
            const a = c1[3] * (1 - t) + c2[3] * t;
            return arrayToRgba([r, g, b, a]);
        }


        function activateStaticPreview() {
            console.log("Activating static preview mode.");
            vtoVideo.classList.add('hidden');
            vtoCanvas.classList.add('hidden');
            videoContainer.classList.remove('face-detected'); // Remove glow
            vtoFaceStatic.classList.remove('hidden');
            vtoLipsOverlay.classList.remove('hidden');
            vtoLipsOverlay.style.backgroundColor = currentLipColor; // Use currentLipColor which is default or last selected
            vtoStatus.innerHTML = '<span class="spinner"></span> Xem trước tĩnh (AI không khả dụng).';
            vtoStatus.style.display = 'flex'; // Ensure display is flex for spinner
            vtoFallbackNote.classList.remove('hidden');
            userChatInput.disabled = true; // Disable chat input
            sendChatBtn.disabled = true;

            if (videoStream) { 
                videoStream.getTracks().forEach(track => track.stop());
                videoStream = null;
                vtoVideo.srcObject = null;
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function activateAdvancedPreview() {
            console.log("Attempting to activate advanced preview mode.");
            vtoFaceStatic.classList.add('hidden');
            vtoLipsOverlay.classList.add('hidden'); // Hide static overlay
            vtoVideo.classList.remove('hidden');
            vtoCanvas.classList.remove('hidden');
            vtoFallbackNote.classList.add('hidden');
            vtoStatus.innerHTML = '<span class="spinner"></span> Đang nhận diện...'; // Initial status
            userChatInput.disabled = false; // Enable chat input
            sendChatBtn.disabled = false;
        }

        function drawLipstick(landmarks) {
            // Smooth color transition logic
            const now = performance.now();
            let interpolatedColor = currentLipColor;

            if (currentLipColor !== targetLipColor) {
                const elapsed = now - transitionStartTime;
                const t = Math.min(elapsed / TRANSITION_DURATION, 1); // Normalize to 0-1
                interpolatedColor = interpolateColor(currentLipColor, targetLipColor, t);
                if (t >= 1) {
                    currentLipColor = targetLipColor; // Transition complete
                }
            } else {
                interpolatedColor = currentLipColor; // No transition needed
            }

            vtoCtx.clearRect(0, 0, vtoCanvas.width, vtoCanvas.height);
            if (!landmarks || landmarks.length === 0) {
                return;
            }

            vtoCtx.fillStyle = interpolatedColor;

            // Draw Upper Lip - Adjusted for mirrored video
            vtoCtx.beginPath();
            const upperLipPoints = LIP_OUTLINE_UPPER.map(idx => ({
                // Flip X coordinate: (1 - normalizedX) * canvasWidth
                x: (1 - landmarks[idx].x) * vtoCanvas.width, 
                y: landmarks[idx].y * vtoCanvas.height
            }));
            vtoCtx.moveTo(upperLipPoints[0].x, upperLipPoints[0].y);
            for (let i = 1; i < upperLipPoints.length; i++) {
                vtoCtx.lineTo(upperLipPoints[i].x, upperLipPoints[i].y);
            }
            vtoCtx.closePath();
            vtoCtx.fill();

            // Draw Lower Lip - Adjusted for mirrored video
            vtoCtx.beginPath();
            const lowerLipPoints = LIP_OUTLINE_LOWER.map(idx => ({
                // Flip X coordinate: (1 - normalizedX) * canvasWidth
                x: (1 - landmarks[idx].x) * vtoCanvas.width, 
                y: landmarks[idx].y * vtoCanvas.height
            }));
            vtoCtx.moveTo(lowerLipPoints[0].x, lowerLipPoints[0].y);
            for (let i = 1; i < lowerLipPoints.length; i++) {
                vtoCtx.lineTo(lowerLipPoints[i].x, lowerLipPoints[i].y);
            }
            vtoCtx.closePath();
            vtoCtx.fill();
            
            // Removed the call to drawGlossEffect
            
            vtoStatus.style.display = 'none'; // Hide status if drawing is successful
            videoContainer.classList.add('face-detected'); // Add glow effect
        }

        // Removed the drawGlossEffect function completely as per user request

        // Function to estimate skin tone
        function estimateSkinTone(landmarks) {
            if (!landmarks || landmarks.length === 0) {
                return null;
            }

            // Create a temporary canvas to sample pixel color
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = vtoVideo.videoWidth;
            tempCanvas.height = vtoVideo.videoHeight;
            
            // Draw the current video frame onto the temporary canvas
            tempCtx.drawImage(vtoVideo, 0, 0, tempCanvas.width, tempCanvas.height);

            // Get a sample point (e.g., center of forehead)
            // This is a simplification. A more robust solution might involve averaging multiple points.
            // Using a central forehead landmark if available, or a general area
            let sampleX, sampleY;
            const centralForeheadLandmarkIndex = 10; // Example landmark for forehead
            if (landmarks[centralForeheadLandmarkIndex]) {
                // Adjust for mirrored video
                sampleX = (1 - landmarks[centralForeheadLandmarkIndex].x) * tempCanvas.width; 
                sampleY = landmarks[centralForeheadLandmarkIndex].y * tempCanvas.height;
            } else {
                // Fallback to a fixed point if landmark not found (less accurate)
                sampleX = tempCanvas.width / 2;
                sampleY = tempCanvas.height / 4; 
            }
            
            // Sample the pixel color
            const imageData = tempCtx.getImageData(sampleX, sampleY, 1, 1).data;
            const r = imageData[0];
            const g = imageData[1];
            const b = imageData[2];

            // Convert RGB to a more descriptive tone. This is a very basic heuristic.
            // You might need a more sophisticated mapping based on real skin tone charts.
            // For simplicity, we'll categorize based on general brightness/hue.
            const brightness = (r + g + b) / 3;
            let tone = "trung tính"; // Neutral

            if (r > 200 && g > 180 && b > 160) {
                tone += " sáng"; // Light
            } else if (r > 150 && g > 120 && b > 100) {
                tone += " trung bình"; // Medium
            } else {
                tone += " tối"; // Dark
            }

            // Check for undertones (simplified)
            // Note: More robust undertone detection would involve analyzing color channels more deeply
            // and potentially using a larger sample area or a dedicated ML model.
            // This is a very basic attempt.
            if (b > r && b > g) {
                tone += " lạnh"; // Cool (more blue/pink)
            } else if (r > g && g > b) {
                tone += " ấm"; // Warm (more yellow/golden)
            } else {
                tone += " trung tính"; // Neutral undertone
            }
            
            return tone.trim(); // Trim any leading/trailing spaces
        }

        async function getGeminiResponse(prompt, isUserInitiated = false) {
            assistantMessageElem.innerHTML = '<span class="assistant-loading-spinner"></span> <span class="assistant-loading-text">Trợ lý ảo đang suy nghĩ...</span>';
            userChatInput.disabled = true;
            sendChatBtn.disabled = true;

            // Add user's prompt to chat history if it's a user-initiated query
            if (isUserInitiated) {
                assistantChatHistory.push({ role: "user", parts: [{ text: prompt }] });
            }

            const payload = { contents: assistantChatHistory };
            // API KEY - Đã được cập nhật với key mới nhất
            const apiKey = "AIzaSyCZZH7f4IHZ_6WpyW03Az7N7qA_ci1x7qM"; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    console.error("Gemini API HTTP Error:", errorBody);
                    throw new Error(`Lỗi HTTP: ${response.status}. Chi tiết: ${errorBody.substring(0, 100)}...`);
                }

                let result;
                try {
                    result = await response.json();
                } catch (jsonError) {
                    console.error("Lỗi phân tích cú pháp JSON từ Gemini API:", jsonError);
                    const rawText = await response.text();
                    console.error("Phản hồi thô từ Gemini API:", rawText);
                    throw new Error("Lỗi: Không thể đọc phản hồi từ trợ lý ảo.");
                }
                
                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    assistantChatHistory.push({ role: "model", parts: [{ text: text }] }); // Add model response to history
                    return text;
                } else {
                    console.error("Gemini API returned an unexpected structure or no content:", result);
                    throw new Error("Xin lỗi, tôi không thể tạo phản hồi lúc này. Cấu trúc phản hồi không mong muốn.");
                }
            }
            catch (error) {
                console.error("Lỗi khi gọi Gemini API:", error);
                return "Đã xảy ra lỗi khi kết nối với trợ lý ảo. Vui lòng kiểm tra kết nối mạng và bảng điều khiển.";
            } finally {
                userChatInput.disabled = false;
                sendChatBtn.disabled = false;
                assistantMessageElem.querySelector('.assistant-loading-spinner')?.remove(); // Remove spinner
                assistantMessageElem.querySelector('.assistant-loading-text')?.remove(); // Remove loading text
            }
        }

        async function recommendLipstick(skinTone) {
            // Initial prompt for skin tone recommendation
            const productNames = products.map(p => p.name).join(', ');
            const prompt = `Tôi có sắc tố da mặt là "${skinTone}". Hãy gợi ý cho tôi 3 màu son trong danh sách sau đây (${productNames}) mà phù hợp nhất với sắc tố da của tôi. Ngoài ra, hãy gợi ý thêm một phong cách trang điểm hoặc phối đồ phù hợp với mỗi màu son đó, và một dịp sử dụng thích hợp. Định dạng câu trả lời của bạn là một danh sách được đánh số rõ ràng, mỗi mục là một màu son gợi ý kèm theo giải thích và các gợi ý thêm.`;
            assistantChatHistory = [{ role: "user", parts: [{ text: prompt }] }]; // Initialize chat history for the first recommendation
            let recommendation = await getGeminiResponse(prompt);
            
            // Remove markdown formatting (asterisks) and quotes
            recommendation = recommendation.replace(/\*/g, '').replace(/"/g, '');
            // Split by newline, filter out empty lines, then join with two newlines for spacing
            const lines = recommendation.split('\n').filter(line => line.trim().length > 0);
            assistantMessageElem.textContent = lines.join('\n\n'); // Ensures 1 empty line between items
            assistantMessageElem.style.textAlign = 'left'; // CHANGED TO LEFT ALIGN
        }

        function sendCompliment(productName) {
            assistantMessageElem.innerHTML = '<span class="assistant-loading-spinner"></span> <span class="assistant-loading-text">Trợ lý ảo đang suy nghĩ...</span>';
            
            setTimeout(() => { // Add a delay for the "thinking" effect
                const product = products.find(p => p.name === productName);
                if (!product || !product.compliments || product.compliments.length === 0) {
                    assistantMessageElem.textContent = "Bạn chọn màu này đẹp quá!";
                    assistantMessageElem.style.textAlign = 'center'; // Compliments look better centered
                    return;
                }

                // Get a random compliment that hasn't been used recently
                let newComplimentIndex;
                do {
                    newComplimentIndex = Math.floor(Math.random() * product.compliments.length);
                } while (newComplimentIndex === lastComplimentIndex && product.compliments.length > 1); // Ensure it's different if more than one option
                
                lastComplimentIndex = newComplimentIndex;
                assistantMessageElem.textContent = product.compliments[newComplimentIndex];
                assistantMessageElem.style.textAlign = 'center'; // Compliments look better centered
            }, 400); // Changed from 700 to 400ms delay
        }

        async function handleUserChat() {
            const userQuery = userChatInput.value.trim();
            if (!userQuery) return;

            userChatInput.value = ''; // Clear input field
            assistantMessageElem.innerHTML = '<span class="assistant-loading-spinner"></span> <span class="assistant-loading-text">Trợ lý ảo đang phản hồi...</span>';
            userChatInput.disabled = true;
            sendChatBtn.disabled = true;

            const response = await getGeminiResponse(userQuery, true); // Send user query to Gemini
            assistantMessageElem.textContent = response;
            assistantMessageElem.style.textAlign = 'left'; // Default to left for general chat
            userChatInput.disabled = false;
            sendChatBtn.disabled = false;
            userChatInput.focus(); // Keep focus on input
        }

        // Event listeners for chat input
        sendChatBtn.addEventListener('click', handleUserChat);
        userChatInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                handleUserChat();
            }
        });


        async function detectionLoop() {
            if (!advancedVtoAvailable || !faceLandmarker) {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                if (!advancedVtoAvailable) activateStaticPreview();
                return;
            }

            if (vtoVideo.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA && !vtoVideo.paused && !vtoVideo.ended) {
                if (vtoVideo.videoWidth > 0 && vtoVideo.videoHeight > 0) {
                    if (vtoCanvas.width !== vtoVideo.videoWidth || vtoCanvas.height !== vtoVideo.videoHeight) {
                        vtoCanvas.width = vtoVideo.videoWidth;
                        vtoCanvas.height = vtoVideo.videoHeight;
                        console.log(`Canvas dimensions updated to: ${vtoCanvas.width}x${vtoCanvas.height}`);
                    }

                    const currentTime = performance.now();
                    if (vtoVideo.currentTime !== lastVideoTime) { 
                        lastVideoTime = vtoVideo.currentTime;
                        try {
                            const faceLandmarkerResult = faceLandmarker.detectForVideo(vtoVideo, currentTime);
                            
                            if (faceLandmarkerResult && faceLandmarkerResult.faceLandmarks && faceLandmarkerResult.faceLandmarks.length > 0) {
                                drawLipstick(faceLandmarkerResult.faceLandmarks[0]); 
                                vtoStatus.style.display = 'none';
                                videoContainer.classList.add('face-detected');

                                // Estimate skin tone once if not locked
                                const newSkinTone = estimateSkinTone(faceLandmarkerResult.faceLandmarks[0]);
                                if (newSkinTone && !isSkinToneLocked) { // Only update if not locked
                                    currentSkinTone = newSkinTone;
                                    isSkinToneLocked = true; // Lock the skin tone after the first successful detection
                                    console.log("Estimated and locked skin tone:", currentSkinTone);
                                    recommendLipstick(currentSkinTone); // Recommend lipstick based on new skin tone
                                }

                            } else {
                                vtoCtx.clearRect(0, 0, vtoCanvas.width, vtoCanvas.height); 
                                vtoStatus.innerHTML = '<span class="spinner"></span> Không tìm thấy khuôn mặt.';
                                vtoStatus.style.display = 'flex';
                                videoContainer.classList.remove('face-detected'); // Remove glow if face not found
                            }
                        } catch (error) {
                            console.error("Lỗi trong quá trình nhận diện khuôn mặt (MediaPipe):", error);
                            vtoStatus.innerHTML = '<span class="spinner"></span> Lỗi nhận diện. Thử lại.';
                            vtoStatus.style.display = 'flex';
                            videoContainer.classList.remove('face-detected');
                        }
                    }
                }
            }
            animationFrameId = requestAnimationFrame(detectionLoop);
        }

        async function startVTO() {
            console.log("Starting VTO initialization..."); // Log to track startup
            vtoStatus.innerHTML = '<span class="spinner"></span> Đang tải...';
            advancedVtoAvailable = await createFaceLandmarker();

            if (!advancedVtoAvailable) {
                console.log("Khởi tạo AI thất bại. Chuyển sang xem trước tĩnh.");
                activateStaticPreview();
                return;
            }
            
            const webcamReady = await setupWebcam();
            if (!webcamReady) {
                console.log("Không thể khởi động webcam. Chuyển sang xem trước tĩnh.");
                advancedVtoAvailable = false; 
                activateStaticPreview(); 
                return;
            }
            
            activateAdvancedPreview();
            console.log("VTO nâng cao đã sẵn sàng. Bắt đầu vòng lặp nhận diện.");
            
            vtoVideo.oncanplay = () => {
                if (advancedVtoAvailable) {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId); 
                    lastVideoTime = -1; 
                    detectionLoop();
                }
            };
            if (vtoVideo.readyState >= HTMLMediaElement.HAVE_ENOUGH_DATA && !vtoVideo.paused) {
                 if (advancedVtoAvailable) {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    lastVideoTime = -1;
                    detectionLoop();
                }
            }
        }
        
        setTimeout(startVTO, 100);

    </script>
</body>
</html>
